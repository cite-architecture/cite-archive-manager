import com.github.rjeschke.txtmark.*

buildscript {
  apply from: "conf.gradle"
  
  apply from: "sysconf/versions.gradle"
  apply from: "sysconf/schemas.gradle"

  repositories {
    mavenCentral()
    maven {
      url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
  }
  dependencies {
    classpath group: 'com.github.rjeschke', name: 'txtmark', version: '0.11'
    // dependencies from versionMap:
    classpath group:   'org.homermultitext', name : 'citemgr' , version: versionMap['citemgr']
    classpath group: 'edu.holycross.shot', name : 'hocuspocus' , version: versionMap['hocuspocus']
    classpath group: 'edu.holycross.shot', name : 'prestochango' , version: versionMap['prestochango']
    classpath group: 'edu.holycross.shot', name : 'abracadabra' , version: versionMap['abracadabra']
    classpath group: 'edu.holycross.shot', name : 'nysi' , version: versionMap['nysi']
    //classpath group:       'org.homermultitext', name : 'hmt-utils', version: versionMap['hmtutils']
  }
}

import edu.holycross.shot.hocuspocus.Corpus
import edu.holycross.shot.prestochango.CollectionArchive
import edu.holycross.shot.abracadabra.CiteIndex
import edu.holycross.shot.nysi.ImgTurtleizer

import org.apache.tools.ant.filters.*

apply plugin: "base"






/* Settings for Digital Scholarly Edition data */
/*
if (hasProperty('dse')) {
    apply from: dse
}
*/
repositories {
    mavenCentral()

    maven {
        url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
    maven {
      url "https://oss.sonatype.org"
    }
}

configurations {
  rdf
}
/*
dependencies {
  rdf
}
*/



/*
task checkti(type: JavaExec) {
    description = "Verifies contents of configured text inventory."

    main = "org.homermultitext.citemanager.TIVerifier"
    args = ["${ctsinventory}"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}
*/

task checkccinv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
      System.err.println "checkccinv:  not yet implemented."
    }
}
/*
task checkidxinv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
        System.err.println "checkidxinv:  not yet implemented."
    }
}


task checkimginv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
        System.err.println "checkimginv:  not yet implemented."
    }
}

*/

task ctstab() {
  description = "Generates a tabular representation of all texts in configured text archive."
}

ctstab.doFirst() {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File tabs = new File(buildDir, "tabs")
  if (! tabs.exists()) {
    tabs.mkdir()
  }
}
ctstab.doLast() {
  println "build corpus from " + ctsinventory + " and " + ctsarchive
  println "Work in " + buildDir
  File inv = new File("${ctsinventory}")
  File citationConfig = new File("${ctscitationconfig}")
  File textArchive = new File("${ctsarchive}")
  File tiSchema =    new File("${project.rootDir}/${textInvSchema}")
  File citationConfSchema =    new File("${project.rootDir}/${citationConfSchema}")
  Corpus c = new Corpus(inv, citationConfig, textArchive, tiSchema)
  c.debug = 10
  c.tabulateRepository(new File(buildDir, "tabs"))
}


task ctsttl() {
  description = "Generates TTL statements about text contents"
}
ctsttl.doFirst {
  System.err.println "ctsttl will use inventory ${ctsinventory}"
  System.err.println "and archive ${ctsarchive}."
  /*
	  if (ttladditions){
			System.err.println "Will add ttl data from ${ttladditions}."
	  } else {
			System.err.println "No additions specified."
	  }
*/

}
ctsttl.doLast {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }

  File inv
  File citeConf
  File archiveDir
  File citationConfig
  String prefix = project.prefixString

  if ((ctsinventory != "") && (ctsarchive != "")) {
    try {
      inv = new File("${ctsinventory}")
      citeConf = new File("${ctscitationconfig}")
      archiveDir = new File("${ctsarchive}")
	  citationConfig = new File("${ctscitationconfig}")
    } catch (Exception e) {
      System.err.println "ctsttl: unable to create inventory and archive!"
      throw e
    }
    Corpus c = new Corpus(inv,citationConfig,archiveDir, new File("${project.rootDir}/${textInvSchema}"))


    System.err.println "Here are the files in my corpus; " + c.filesInArchive()
    File ttlDir = new File(buildDir, "ttl")



    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File ttlFile = new File(ttlDir,"cts.ttl")
    c.turtleizeRepository(ttlDir, true)
  }
}


task filterImgs(type: Copy) {
  description = "Filter copies configurable image collection info."
  from (file(imgcolldir)) {
    include '*.csv'
  }
  filter(ReplaceTokens, tokens : [pyramids : pyramids] )
  into "${buildDir}/images"
}
filterImgs.doFirst {
  println "Filter copy images in " + imgcolldir
}


task imgttl(dependsOn: [filterImgs]) {
  description = "Generates RDF for configured NYSI"
}
imgttl.doLast {
  boolean prefix = project.hasProperty("prefixAll")

  File rdfDir = new File("${buildDir}/ttl")
  if (! rdfDir.exists()) {
    rdfDir.mkdir()
  }
  File ttlFile = new File(rdfDir,"citeimgs.ttl")

  ImgTurtleizer imgttl = new ImgTurtleizer("${buildDir}/images")

  File imageDir = new File("${buildDir}/images")
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  if (! imageDir.exists()) {
    imageDir.mkdir()
  }

  imgttl.ttl(ttlFile, prefix)
}




task ccttl {
  description = "Generates RDF for Collections configured for prestochango"
}
ccttl.doLast {
  boolean prefix = project.hasProperty("prefixAll")

  File schemaFile = new File("${project.rootDir}/${collectionInvSchema}")

  if ((collinv != "") && (collarchive != "")) {
	File invFile = new File(collinv)
	File archiveDir = new File(collarchive)
	CollectionArchive cc = new CollectionArchive(invFile, schemaFile, archiveDir)
	//cc.debug = 5
	println "\nFrom inventory in ${collinv} and data in ${collarchive}:"
	println "\tCollection list:  " + cc.getCollectionList() + "\n"
	if (! buildDir.exists()) {
	  buildDir.mkdir()
	}
	File ttlDir = new File(buildDir, "ttl")
	if (! ttlDir.exists()) {
	  ttlDir.mkdir()
	}
	File testOut = new File(ttlDir, "collections.ttl")
	cc.ttl(testOut, prefix)
  }
}


task idxttl () {
  description = "Generates RDF for indices configured for abracadabra"
}
idxttl.doLast {
  boolean prefix = project.hasProperty("prefixAll")

  File inv
  File idxDir

  if ((idxinv != "") && (idxarchive != ""))   {
    try {
      inv = new File("${idxinv}")
      idxDir = new File("${idxarchive}")
    } catch (Exception e) {
      System.err.println "idxttl: unable to make index inventory and archive."
      throw e
    }
    CiteIndex idx = new CiteIndex(inv, idxDir)

    if (! buildDir.exists()) {
      buildDir.mkdir()
    }
    File ttlDir = new File(buildDir, "ttl")
    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File outFile = new  File (ttlDir,"indices.ttl")
    idx.ttl(outFile, prefix)
  }
}


task ttl (dependsOn: [ctsttl, imgttl, ccttl, idxttl]) {
  description = "Concatenates separate TTL files into a single graph."
  doLast {
    String charEnc = "UTF-8"
    String prefix = "${prefixString}"

    File ctsttl = new File("${buildDir}/ttl/cts.ttl")
    File collectionsttl = new File("${buildDir}/ttl/collections.ttl")
    File idxttl = new File("${buildDir}/ttl/indices.ttl")
    File citeimgttl = new File("${buildDir}/ttl/citeimgs.ttl")

    def srcFiles =  [ctsttl, collectionsttl, idxttl, citeimgttl]

    File ttl = new File("${buildDir}/ttl/all.ttl")
    ttl.append( prefix )

    srcFiles.each {  f ->
      if (f.exists()) {
	ttl.withWriterAppend(charEnc) {writer ->
	  f.newReader(charEnc).eachLine {String line ->
	    writer << "\n${line}"
	  }
	}
      } }

// too slow to tolerate :-(
/*
        System.err.println "Adding data from cts ttl ..."
        ctsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }

        System.err.println "Adding data from collections ttl ..."
        collectionsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }


        System.err.println "Adding data from index ttl ..."
        idxttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }



        System.err.println "Adding data from image ttl ..."
        citeimgttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }
*/

// Big project runs out of memory with this approach :-(
//+ ctsttl.getText(charEnc) + collectionsttl.getText(charEnc) + idxttl.getText(charEnc) + citeimgttl.getText(charEnc), charEnc)


        System.out.println "\nCompleted generating all TTL in ${buildDir}/ttl.\n"
    }
}





task zipTtl(type: Zip, dependsOn: [ttl]) {
  description = "Builds a zip file of all TTL output"
  from(file("${buildDir}/ttl"))
  include("** / *.ttl")
}

artifacts {
  rdf zipTtl
}
