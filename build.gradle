

buildscript {
  apply from: "conf.gradle"

  apply from: "sysconf/versions.gradle"
  apply from: "sysconf/schemas.gradle"

  repositories {
    mavenCentral()
    maven {
      url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
  }
  dependencies {


    classpath group:   'edu.harvard.chs', name : 'cite' , version: versionMap['cite']
    classpath group:   'org.homermultitext', name : 'citemgr' , version: versionMap['citemgr']
    classpath group: 'edu.holycross.shot', name : 'hocuspocus' , version: versionMap['hocuspocus']
    classpath group: 'edu.holycross.shot', name : 'prestochango' , version: versionMap['prestochango']
    classpath group: 'edu.holycross.shot', name : 'abracadabra' , version: versionMap['abracadabra']
    classpath group: 'edu.holycross.shot', name : 'nysi' , version: versionMap['nysi']
    //classpath group:       'org.homermultitext', name : 'hmt-utils', version: versionMap['hmtutils']
  }
}

import edu.holycross.shot.hocuspocus.Corpus
import edu.holycross.shot.prestochango.CollectionArchive
import edu.holycross.shot.abracadabra.CiteIndex
import edu.holycross.shot.nysi.ImgTurtleizer


import edu.holycross.shot.hocuspocus.TextInventory
import edu.harvard.chs.cite.CtsUrn

import org.apache.tools.ant.filters.*

apply plugin: "base"






/* Settings for Digital Scholarly Edition data */
/*
if (hasProperty('dse')) {
    apply from: dse
}
*/
repositories {
    mavenCentral()

    maven {
        url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
    maven {
      url "https://oss.sonatype.org"
    }
}



/*
task checkti(type: JavaExec) {
    description = "Verifies contents of configured text inventory."

    main = "org.homermultitext.citemanager.TIVerifier"
    args = ["${ctsinventory}"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


task checkccinv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
      System.err.println "checkccinv:  not yet implemented."
    }
}

task checkidxinv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
        System.err.println "checkidxinv:  not yet implemented."
    }
}


task checkimginv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
        System.err.println "checkimginv:  not yet implemented."
    }
}

*/

task ctstab() {
  description = "Generates a tabular representation of all texts in configured text archive."
}

ctstab.doFirst() {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File tabs = new File(buildDir, "tabs")
  if (! tabs.exists()) {
    tabs.mkdir()
  }
}
ctstab.doLast() {
  println "Tabulating corpus from configuration in " + ctsinventory + " and " + ctscitationconfig + " against local files in " + ctsarchive
  println "Saving results in ${buildDir}/tabs"
  File inv = new File("${ctsinventory}")
  File citationConfig = new File("${ctscitationconfig}")
  File textArchive = new File("${ctsarchive}")
  File tiSchema =    new File("${project.rootDir}/${textInvSchema}")
  File citationConfSchema =    new File("${project.rootDir}/${citationConfSchema}")
  Corpus c = new Corpus(inv, citationConfig, textArchive, tiSchema)
  //c.debug = 10
  c.tabulateRepository(new File(buildDir, "tabs"))
}


task ctsttl() {
  description = "Generates RDF representation of all texts in configured text archive"
}
ctsttl.doFirst {
  println "Building RDF for corpus from configuration in " + ctsinventory + " and " + ctscitationconfig + " against local files in " + ctsarchive
  println "Saving results in ${buildDir}/tabs"
}

ctsttl.doLast {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }

  File inv
  File citeConf
  File archiveDir
  File citationConfig
  String prefix = project.prefixString

  if ((ctsinventory != "") && (ctsarchive != "")) {
    try {
      inv = new File("${ctsinventory}")
      citeConf = new File("${ctscitationconfig}")
      archiveDir = new File("${ctsarchive}")
	  citationConfig = new File("${ctscitationconfig}")
    } catch (Exception e) {
      System.err.println "ctsttl: unable to create inventory and archive!"
      throw e
    }


    // TEST:

    TextInventory ti = new TextInventory(inv)
    Corpus c = new Corpus(inv,citationConfig,archiveDir, new File("${project.rootDir}/${textInvSchema}"))


    System.err.println "Here are the files in my corpus; " + c.filesInArchive()
    File ttlDir = new File(buildDir, "ttl")



    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File ttlFile = new File(ttlDir,"cts.ttl")
    c.turtleizeRepository(ttlDir, true)
  }
}



task filterImgs(type: Copy) {
  description = "Filter copies configurable image collection info."
  from (file(imgcolldir)) {
    include '*.csv'
  }
  filter(ReplaceTokens, tokens : [pyramids : pyramids] )
  into "${buildDir}/images"
}
filterImgs.doFirst {
  println "Filter copy images in " + imgcolldir
}


task imgttl(dependsOn: [filterImgs]) {
  description = "Generates RDF for configured NYSI"
}
imgttl.doLast {
  boolean prefix = project.hasProperty("prefixAll")

  File rdfDir = new File("${buildDir}/ttl")
  if (! rdfDir.exists()) {
    rdfDir.mkdir()
  }
  File ttlFile = new File(rdfDir,"citeimgs.ttl")

  ImgTurtleizer imgttl = new ImgTurtleizer("${buildDir}/images")

  File imageDir = new File("${buildDir}/images")
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  if (! imageDir.exists()) {
    imageDir.mkdir()
  }

  imgttl.ttl(ttlFile, prefix)
}



task ccttl {
  description = "Generates RDF for Collections configured for prestochango"
}
ccttl.doLast {
  boolean prefix = project.hasProperty("prefixAll")

  File schemaFile = new File("${project.rootDir}/${collectionInvSchema}")

  if ((collinv != "") && (collarchive != "")) {
	File invFile = new File(collinv)
	File archiveDir = new File(collarchive)
	CollectionArchive cc = new CollectionArchive(invFile, schemaFile, archiveDir)
	//cc.debug = 5
	println "\nFrom inventory in ${collinv} and data in ${collarchive}:"
	println "\tCollection list:  " + cc.getCollections() + "\n"
	if (! buildDir.exists()) {
	  buildDir.mkdir()
	}
	File ttlDir = new File(buildDir, "ttl")
	if (! ttlDir.exists()) {
	  ttlDir.mkdir()
	}
	File testOut = new File(ttlDir, "collections.ttl")
	//testOut.setText(cc.turtleizeArchive())
	//cc.ttl(testOut, prefix)
	testOut.setText("")
	if (prefix){ testOut << cc.prefix }
	testOut << cc.ttlExtensionMap()
	cc.collections.each { c ->
		testOut << cc.turtleizeCollection(c)
	}
  }
}


task idxttl () {
  description = "Generates RDF for indices configured for abracadabra"
}
idxttl.doLast {
  boolean prefix = project.hasProperty("prefixAll")

  File inv
  File idxDir

  if ((idxinv != "") && (idxarchive != ""))   {
    try {
      inv = new File("${idxinv}")
      idxDir = new File("${idxarchive}")
    } catch (Exception e) {
      System.err.println "idxttl: unable to make index inventory and archive."
      throw e
    }
    CiteIndex idx = new CiteIndex(inv, idxDir)

    if (! buildDir.exists()) {
      buildDir.mkdir()
    }
    File ttlDir = new File(buildDir, "ttl")
    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File outFile = new  File (ttlDir,"indices.ttl")
    idx.ttl(outFile, prefix)
  }
}



//task ttl (dependsOn: [ctsttl, imgttl, ccttl, idxttl]) {
task ttl (dependsOn: [ctsttl, imgttl, ccttl, idxttl]) {
  description = "Concatenates separate TTL files into a single graph."
  doLast {
    String charEnc = "UTF-8"
    String prefix = "${prefixString}"

    // TRY LIKE THIS ?
    //src.withInputStream { input ->
    //   target << input
    //}

    def fileSet = [
      new File("${buildDir}/ttl/cts.ttl"),
      new File("${buildDir}/ttl/collections.ttl"),
      new File("${buildDir}/ttl/indices.ttl"),
      new File("${buildDir}/ttl/citeimgs.ttl")
    ]
    File composite = new File(buildDir, "all.ttl")
      
    fileSet.each {  f ->
      if (f.exists()) {
	f.withInputStream { input ->
	  composite << input
	}
	//ttl.withWriterAppend(charEnc) { writer ->
	// f.newReader(charEnc).eachLine {String line ->
	//   writer << "\n${line}"
	// }
	
	}
      }
    }
  }
// too slow to tolerate :-(
/*
        System.err.println "Adding data from cts ttl ..."
        ctsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }

        System.err.println "Adding data from collections ttl ..."
        collectionsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }


        System.err.println "Adding data from index ttl ..."
        idxttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }



        System.err.println "Adding data from image ttl ..."
        citeimgttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }
*/


/*s
// Big project runs out of memory with this approach :-(
//+ ctsttl.getText(charEnc) + collectionsttl.getText(charEnc) + idxttl.getText(charEnc) + citeimgttl.getText(charEnc), charEnc)


        System.out.println "\nCompleted generating all TTL in ${buildDir}/ttl.\n"
    }
}*/
